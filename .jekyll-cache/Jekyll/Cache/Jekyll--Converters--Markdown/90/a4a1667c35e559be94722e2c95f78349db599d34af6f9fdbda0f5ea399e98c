I"'<p><em>Estudo Universidade</em><br /><br />
Â´Algoritmos e programaÃ§Ã£o de computadores 2 (python)Â´<br /><br />â€¦<!--more-->
<em>Texto base 1 parte 1 - MemÃ³ria</em><br /><br />
O texto trata sobre tipos mutÃ¡veis e imutÃ¡veis na linguagem Python. E que todos os tipos numÃ©ricos; como bool, interface, float e complex; sÃ£o imutÃ¡veis.<br /><br />
As atribuiÃ§Ãµes em python funcionam da seguinte forma, ao fazer Â´A=5Â´ o python cria a variÃ¡vel e um objeto int e armazena na memÃ³ria o valor 5, isto se chama ponteiro pois a variavel Â´AÂ´ aponta ao valor Â´5Â´. E se vocÃª atribuir outro valor Ã¡ variÃ¡vel A por exemplo Â´A=10Â´ o python esquece, ou melhor, perde o ponteiro ao valor Â´5Â´ e aponta ao novo valor Â´10Â´, ao perder o ponteiro nÃ£o podemos mais acessar o valor (mas podemos criar outro).<br /><br />
O mesmo nÃ£o ocorre a uma lista, pois podemos fazer o seguinte â€˜lista=[2,3,6]â€™ como dito anteriormente a linguagem cria a variÃ¡vel e cria a lista na memÃ³ria, e ainda aponta a variÃ¡vel ao endereÃ§o da memÃ³ria. Ao fazermos o seguinte Â´lista[1]=4Â´ a linguagem nÃ£o cria outro objeto entÃ£o o endereÃ§o Ã© o mesmo. EntÃ£o a lista Ã© mutÃ¡vel.<br /><br />
O autor ainda brinca da seguinte forma: e quanto ao objeto str (string), tecnicamente ela Ã© uma lista de caracteres, tanto Ã© que podemos acessar um item fazendo assim: Â´umaString=â€acabaâ€Â´ e ainda Â´print(umaString[0])Â´. O autor fala que irÃ¡ ver e executa algo parecido porÃ©m deu erro. E conclui que Strings tambÃ©m sÃ£o Â´imutÃ¡veisÂ´.<br /><br />
Sobre a mutabilidade, o autor da o exemplo com listas fazendo da seguinte forma:<br /><br />
Â´listA=[2,4,6]<br />
listB=listAÂ´<br /><br />
O que fizemos acima foi criar a variavel listA e apontamos ao valor Â´[2,4,6]Â´ e na linha abaixo atribuimos a mesma lista a Â´listBÂ´. Em seguida fez a seguinte atribuiÃ§Ã£o: Â´listB[2]=8Â´<br /><br />
Na atribuiÃ§Ã£o acima, o indice dois da lista serÃ¡ alterada nas duas variÃ¡veis, pois as duas apontam ao mesmo objeto. E se fizermoso codigo abaixo obteremos o mesmo valor.<br /><br />
Â´print(listA)<br />
print(ListB)Â´<br /><br />
Â´SwapÂ´ - o python com atribuiÃ§Ãµes mutiplas permite fazer a troca de objetos entre variaveis, para fazer isto precisariamos de mais uma variavel, fariamos da seguinte forma:<br /><br />
Â´a=3<br />
b=4Â´<br /><br />
Essas sÃ£o as variaveis e se quisessemos trocalas fariamos assim:<br /><br />
Â´temp=a<br />
a=b<br />
b=tempÂ´<br /><br />
E com a atribuiÃ§Ã£o multipla fariamos da seguinte forma:<br /><br />
Â´a, b = b, aÂ´<br /><br />
Embora que nÃ£o vejo uma aplicaÃ§Ã£o, com a atribuiÃ§Ã£o multipla economiza memÃ³ria descartando a variavel temp.<br /><br />
<em>Texto base 1 parte 2 - Arquivos</em><br /><br />
No texto o autor da uma breve informaÃ§Ã£o sobre arquivos, e sobre o sistema de arquivos, que eles sÃ£o feitos para organizar nossos arquivos e que o sistema de arquivos contem pastas (chamados diretÃ³rios) onde colocamos nossos arquivos.<br /><br />
O topo da hierarquia do sistema de arquivos. onde o topo Ã© denominado diretÃ³rio raiz e com uma razÃ£o, o topo Ã© o inicio da raiz, e os niveis abaixo sÃ£o raizes â€œfilhasâ€. E que o diretÃ³rio raiz varia de acordo com o sistema operacional.<br /><br />
Cada arquivo no sistema pode ser referenciado com um caminho, e este caminho pode ser absoluto, no qual deve ser especificado todo os diretÃ³rios incluindo o raiz, no linux um arquivo de texto na pasta Documents do usuario Ã© feito da seguinte forma:<br /><br />
Â´/users/rodrigo/Documents/arquivo.txtÂ´<br /><br />
O caminho tambÃ©m pode ser relativo, onde partimos do diretÃ³rio atual. Portanto se estivessemos no diretorio Documents (citado acima) e quisessemos usar um arquivo no diretorio /users/shared teriamos que fazer da seguinte forma:<br /><br />
Â´../../shared/outroArquivo.txtÂ´<br /><br />
Cada Â´../Â´ se refere ao diretÃ³rio pai do diretorio atual, entÃ£o o diretorio pai do Documents Ã© rodrigo, o diretorio pai do diretorio rodrigo Ã© users ai acessamos a outra pasta e o arquivo.<br /><br />
Sobre a leitura de arquivos, o python tem o mÃ©todo Â´open(â€˜nomeArquivo.txtâ€™, â€˜râ€™)Â´ que retorna um objeto do tipo Â´Fluxo de Entrada ou SaÃ­daÂ´ e que esse objeto Ã© chamado pelos programadores como Â´objeto de arquivoÂ´. Os parÃ¢metros do mÃ©todo open() sÃ£o o nome do arquivo (um objeto do tipo str) e o modo de abertura (outro objeto str) que podem ser â€˜râ€™ = leitura, â€˜wâ€™=escrita, â€˜aâ€™ = acrescimo (ou em ingles Â´appendÂ´) este mÃ©todo adiciona um novo conteudo ao final do arquivo.<br /><br />
Alguns metodos de arquivos sÃ£o arquivoEntrada.read() le o arquivo inteiro, arquivoEntrada.read(n) onde n Ã© a quantidade de caracteres a serem lidos, arquivoEntrada.readline() lÃª uma linha inteira, arquivoEntrada.readlines() le o arquivo inteiro e retorna uma lista de linhas do arquivo, arquivoEntrada.write(s) escreve a string s no arquivo, e arquivoEntrada.close() fecha o arquivo.<br /><br />
E ao ler um arquivo o python cria um cursor que aponta a um caractere do arquivo, ao abrir um arquivo com o texto abaixo o cursor apontarÃ¡ ao primeiro caractere. EntÃ£o o cursor receberÃ¡ o caractere â€˜Eâ€™.<br /><br />
Â´Este arquivo tem 3 linhas.<br />
<br />
A linha acima estÃ¡ em branco.Â´<br /><br />
Se fizermos Â´arquivo.read(5)Â´ ele lerÃ¡ os 5 primeiros caracteres e apontarÃ¡ ao proximo caractere, entao o cursor receberÃ¡ o caractere â€˜aâ€™. E se apos o Â´read(5)Â´ fizermos o Â´readline()Â´ o python lerÃ¡ o restante da linha entao retorna â€˜rquivo tem 3 linhas.\nâ€™. E assim funciona, ele le os caracteres e o cursor aponta ao proximo caractere.<br /><br />
E o autor mostra como usÃ¡los, fazendo exemplos prÃ¡ticos como o read() que Ã© util para ler o arquivo todo e substituir uma substring a uma outra string, contar quantos caracteres o arquivo possui, etc.<br /><br />
O readlines() Ã© util para ler uma linha inteira, usado para por exemplo analisar um log de um servidor.  que este mÃ©todo Ã© melhor para arquivos grandes pois nÃ£o temos o arquivo inteiro na memÃ³ria.<br /><br />
A seguir o autor mostra como ocorre a gravaÃ§Ã£o em um arquivo. E que para abrir o arquivo para gravaÃ§Ã£o devemos usar Â´open(â€˜nomeArquivo.txtâ€™,â€™wâ€™)Â´ e que deste modo se o arquivo nÃ£o existir o python o criarÃ¡. E abrindo com o â€˜wâ€™ (do segundo parametro) temos a funÃ§Ã£o Â´write()Â´ para gravar dados e comeÃ§arÃ¡ na posiÃ§Ã£o do cursor e retorna a quantidade de caracteres escrito, se quiser escrever novamente o cursor estarÃ¡ no final da string escrita anteriormenteâ€¦ E ainda que se quisermos escrever algo diferente de string devemos converter para string antes de escrevermos com o str().<br /><br />
<em>Texto base 2 - RevisÃ£o de algoritmos</em><br /><br />
O segundo texto base desta semana fala sobre algorÃ­tmos, que eles sÃ£o um conjunto de passos bem definidos que tem como objetivo solucionar algum problema computacional ou nÃ£o. Deu exemplos de algoritmos nÃ£o computacionais (como fazer um sorvete) e computacionais como o algoritmo de euclides para obtenÃ§Ã£o do mdc de dois numeros. E ainda que os algoritmos tem valores de entrada e valores de saida. Um algoritmo deve ser coerente com as entradas, finito, correto, e com passos que possam ser entendidos pelo usuÃ¡rios.<br /><br />
E que os algoritmos podem ser escritos / descritos em modo texto (com uma linguagem e semantica) ou de modo grÃ¡fico (como fluxogramas que tambÃ©m tem uma semantica de simbolos usados). Os elementos grÃ¡ficos de um fluxogramas sÃ£o conectados por setas que indicam o caminho a ser percorrido pelo algoritmo. E o texto continua, sÃ³ nÃ£o estou com paciÃªncia de continuar.<br /><br />
<em>Texto base 3 - Arquivos</em><br /><br />
Este texto base, tambÃ©m nÃ£o o li todo, mas pelo visto trata da parte dois do texto base 1 porÃ©m mais detalhado. Como a codificaÃ§Ã£o ASCII, UTF-8, etc. E ao contrÃ¡rio do primeiro ele comeÃ§a explicando pela escrita de arquivos (provavelmente por ter somente um mÃ©todo referente, o arquivo.write()). E sobre a abertura de arquivos em python com o metodo open(), ele diz ainda que hÃ¡ outros parÃ¢metros neste mÃ©todo, como descreve abaixo:<br /><br />
Â´open(arquivo, modo=â€™râ€™, buffering=-1, encoding=None, errors=None, newline=None, closefd=true, opener=none)Â´<br /><br />
E explica cada um parametro, onde file Ã© o arquivo a ser aberto, o mode que sÃ£o os modos de leitura-escrita-ambos-adiÃ§Ã£o, sobre o buffering Ã© a bufferizaÃ§Ã£o do arquivo com as opÃ§Ãµes 0 (nÃ£o usa buffer) - 1 (sÃ³ se usa em arquivos texto e o buffer terÃ¡ uma linha do arquivo - &gt;1 o inteiro indica o tamanho do buffer - e se nÃ£o for especificado adotarÃ¡ o valor -1 que Ã© o metodo padrÃ£o de buffer, o encode se trata das codificaÃ§Ãµes como â€œansiâ€ e â€œutf-8â€. Os outros parametros nÃ£o serÃ£o abordados no livro. E mostra os metodos para arquivos, como close(), flush() este mÃ©todo descarrega o buffer do arquivo aberto para a gravaÃ§Ã£o do mesmo sem fechar, read() readline() readlines() write(s) jÃ¡ abordados anteriormente, writelines(lista) que grava todos os itens da lista no arquivo, e seek(int) que leva o cursor na posiÃ§Ã£o int de caracteres do arquivo.<br /><br /></p>

<div id="disqus_thread"></div>
<script>

/**
*  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
*  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/
/*
var disqus_config = function () {
this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
(function() { // DON'T EDIT BELOW THIS LINE
var d = document, s = d.createElement('script');
s.src = 'https://rregio-top.disqus.com/embed.js';
s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>

<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
:ET